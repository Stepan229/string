#ifndef SSCANF_H
#define SSCANF_H

#include "s21_string.h"

/**
 * Cтруктура описывает один токен из форматной строки
 */
typedef struct sscanf_token {
  int asterisk;  // маркировка наличия звездочки в форматной строке
  int width;  // ширина, будет меняться в процессе работы (изначально равна
              //  width_const)
  int width_const;  // ширина, не меняется
  char length;      // длина "l, h и т.д."
  char spec;        // сам спецификатор d, c, s, x и т.д.
  char str_to_assign[1024];  // здесь хранится итоговая строка
  void* arg;  // здесь хранится адрес куда запишутся данные
  int count_symb;  // число обработнных символов для спецификатора n
  int spaces;      // маркер наличия пробелов
} token;

/**
 * Функция для проверки не состоит ли вся строка из пробелов, табуляций и т.п.
 * @param str Обрабатываемая строка
 * @param str_len Длина обрабатываемой строки
 * @return Возвращает 1, в случае, если строка полностью состоит из пробелов. 0
 * при наличии любого символа, отличного от пробела
 */
int check_str(const char* str, int str_len);

/**
 * Перевод символов ASCII в целое число
 * @param str Обрабатываемая строка
 * @param index Текущий индекс строки, необходим для смещения строки после
 * преобразования, вне функции
 * @return Возвращает проебразовнное целое число
 */
int s21_atoi(const char* str, int* index);

/**
 * Выделение токена из форматной строки
 * @param _format Указатель на структуру для хранения информации о токене
 * @param format Форматная строка
 * @param index Текущий индекс форматной строки
 * @return Возвращает индекс форматной строки, со смещением, после обработки
 */
int parse_format(token* _format, const char* format, int index);

/**
 * Функция для очистки форматного токена
 * @param _format Указатель на структуру для хранения информации о токене
 */
void clear_token(token* _format);

/**
 * Обработка спецификатора %%
 * @param str Обрабатываемая строка
 * @param str_index Текущий индекс обрабатываемой строки
 * @param flag Флаг прнимает значение 1, в случае если не был найден символ % в
 * обрабатываемой строке. Сигнализирует об ошибке
 */
void get_percent(const char* str, int* str_index, int* flag);

/**
 * Обработка строки, задействование спецификторов
 * @param str Обрабатываемая строка
 * @param tmp_str Временная строка, для хранения части исходной строки
 * @param _format Указатель на структуру для хранения информации о токене
 * @param str_index Текущий индекс обрабатываемой строки
 * @param status Переменная сигнализирует об успешной обработке спецификатора,
 * переменная суммируется к возвращаемому значению s21_sscanf
 * @return Возвращает индекс исходной строки, со смещением, после обработки
 */
int engage_specifiers(const char* str, char* tmp_str, token* _format,
                      int str_index, int* status);

/**
 * Проверка шестнадцатиричного числа
 * @param _format Указатель на структуру для хранения информации о токене
 * @param tmp_str Временная строка, для хранения части исходной строки
 * @param sym Проверяемый символ исходной строки
 * @param flag Флаг ширины, передаваемый из функции str_divide
 * @return Возвращает 1, если число корректно, 0 в противном случае
 */
int check_hex(token* _format, char* tmp_str, char sym, int flag);

/**
 * Проверка числа
 * @param str Обрабатываемая строка
 * @param tmp_str Временная строка, для хранения части исходной строки
 * @param _format Указатель на структуру для хранения информации о токене
 * @param str_index Текущий индекс обрабатываемой строки
 * @param flag Флаг ширины, передаваемый из функции str_divide
 * @param uncert Сигнализирует о том, что число нельзя точно определить. -1 -
 * число является бесконечностью; 1 - not a number(NaN); 0 - число нормальное
 * @return Возвращает 1, если число корректно, 0 в противном случае
 */
int check_number(const char* str, char* tmp_str, token* _format, int str_index,
                 int flag, int* uncert);

/**
 * Проверка числа с плавающей точкой
 * @param _format Указатель на структуру для хранения информации о токене
 * @param tmp_str Временная строка, для хранения части исходной строки
 * @param sym Проверяемый символ исходной строки
 * @return  Возвращает 1, если число корректно, 0 в противном случае
 */
int check_double(token* _format, char* tmp_str, char sym);

/**
 * Проверка на бесконечность и NaN
 * @param str Обрабатываемая строка
 * @param str_index Текущий индекс обрабатываемой строки
 * @return  Возвращает -1, если в обрабатываемой строке бесконечность, 1 если
 * NaN и 0 если число нормальное
 */
int check_inan(const char* str, int str_index);

/**
 * Выделение части строки в соответствии со спецификатором
 * @param str Обрабатываемая строка
 * @param tmp_str Временная строка, для хранения части исходной строки
 * @param _format Указатель на структуру для хранения информации о токене
 * @param str_index Текущий индекс обрабатываемой строки
 * @return Возвращает смещенный индекс обрабатываемой строки
 */
int str_divide(const char* str, char* tmp_str, token* _format, int str_index);

/**
 * Обработка спецификаторов
 * @param _format Указатель на структуру для хранения информации о токене
 * @return Возвращает число успешно обработанных токенов
 */
int specifiers_process(token* _format);

/**
 * Обработка спецификатора %c
 * @param _format Указатель на структуру для хранения информации о токене
 * @return Возвращает число успешных записей символа (всегда 1)
 */
int process_c(token* _format);

/**
 * Обработка спецификаторов %d и %i
 * @param _format Указатель на структуру для хранения информации о токене
 * @return Возвращает 1 если удалось считать и записать число, 0 в противном
 * случае
 */
int process_di(token* _format);

/**
 * Выделение числа из строки
 * @param _format Указатель на структуру для хранения информации о токене
 * @param number Указатель на переменную, куда будет записан результат
 * @return Возвращает 1 если удалось считать число, 0 в противном случае
 */
int process_number(token* _format, long long int* number);

/**
 * Определение системы счисления для числа
 * @param _format Указатель на структуру для хранения информации о токене
 * @param shift Символьное смещение(необходимо для пропуска первых символов
 * шестнадцатиричных чисел "0xЧИСЛО")
 * @return Возвращает определенную систему счисления 8, 10 или 16
 */
int get_notation(token* _format, int* shift);

/**
 * Обработка спецификаторов %o, %u, %x и %X
 * @param _format Указатель на структуру для хранения информации о токене
 * @return Возвращает 1 если удалось считать и записать число, 0 в противном
 * случае
 */
int process_ouxX(token* _format);

/**
 * Обработка спецификаторов %p
 * @param _format Указатель на структуру для хранения информации о токене
 * @return Возвращает 1 если удалось считать и записать число, 0 в противном
 * случае
 */
int process_p(token* _format);

/**
 * Обработка спецификаторов %p
 * @param _format Указатель на структуру для хранения информации о токене
 * @return Возвращает 1 если удалось считать и записать строку, 0 в противном
 * случае
 */
int process_s(token* _format);

/**
 * Обработка спецификаторов %n
 * @param _format Указатель на структуру для хранения информации о токене
 * @return Возвращает 1. По адресу _format.arg записывется количество считанных
 * символов
 */
int process_n(token* _format);

/**
 * Обработка спецификаторов %e, %f, %g, %E и %G
 * @param _format Указатель на структуру для хранения информации о токене
 * @return Возвращает 1 если удалось считать и записать число, 0 в противном
 * случае
 */
int process_efgEG(token* _format);

/**
 * Выделение числа c плавающей точкой из строки
 * @param _format Указатель на структуру для хранения информации о токене
 * @param number Указатель на переменную, куда будет записан результат
 * @return Возвращает 1 если удалось считать число, 0 в противном случае
 */
int process_double(token* _format, long double* number);

/**
 * Обработка точки в числе с плавающей точкой и "e" в научной нотации
 * @param _format Указатель на структуру для хранения информации о токене
 * @param index_point Индекс строки с числом, где находится точка
 * @param lenght Длина строки с числом
 * @return Возвращает множитель для считанного числа в функции process_double,
 * домножение позволяет расположить точку в нужном месте
 */
long double process_dot_e(token* _format, int index_point, int lenght);

/**
 * Обработка "e" в научной нотации числа
 * @param _format Указатель на структуру для хранения информации о токене
 * @param e_sign Адрес числа, куда будет записан знак экспоненты
 * @param power Адрес числа, куда будет записан множитель экспоненты
 * @return Возвращает 0, в случае если число записано не в научной нотации, в
 * противном случае возвращает индекс массива, где расположена "e"
 */
int check_e(token* _format, int* e_sign, int* power);

/**
 * Обработка бесконечности и NaN
 * @param _format Указатель на структуру для хранения информации о токене
 * @param sign Знак перед NaN
 * @return Возвращает 0, в случае если в строке нет бесконечности или NaN, в
 * противном случае возвращает бесконечность или NaN или -NaN, в зависимости от
 * исходной строки
 */
long double process_inan(token* _format, int sign);

/**
 * Проверка символа исходной строки на пробелы
 * @param _format Указатель на структуру для хранения информации о токене
 * @param str Обрабатываемая строка
 * @param str_index Текущий индекс обрабатываемой строки
 * @param format_char Текущий символ форматной строки
 * @param flag Флаг, принимающий значение 1 при ошибке и значение 0, при
 * нормальной работе программы
 * @return Возвращает смещенный индекс обрабатываемой строки
 */
int check_char(token* _format, const char* str, int str_index, char format_char,
               int* flag);

/**
 * Подсчет символов для спецификатора %n
 * @param _format Указатель на структуру для хранения информации о токене
 * @param str_index Текущий индекс обрабатываемой строки
 * @param str_len Длина обрабатываемой строки
 * @param format_len Длина форматной строки
 * @param format_index Текущий индекс форматной строки
 */
void symbol_count(token* _format, int str_index, int str_len, int format_len,
                  int format_index);
#endif  // SRC_SSCANF_H